<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技忆</title>
  <subtitle>Phoebe&#39;s little progress</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://phoebepan.cn/"/>
  <updated>2017-06-07T12:56:54.000Z</updated>
  <id>http://phoebepan.cn/</id>
  
  <author>
    <name>Phoebe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据可视化——Seaborn</title>
    <link href="http://phoebepan.cn/2017/06/06/learn_seaborn/"/>
    <id>http://phoebepan.cn/2017/06/06/learn_seaborn/</id>
    <published>2017-06-06T07:30:16.000Z</published>
    <updated>2017-06-07T12:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>EDA过程中，想要更了解你的数据，选择一个合适的可视化工具，可以说会让你的工作事半功倍。<br>本文主要介绍一个以matplotlib作为底层，更易上手的作图库<code>seaborn</code>。</p>
</blockquote>
<a id="more"></a>
<h3 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h3><p>基于matplotlib的可视化库，旨在使默认的数据可视化更加悦目，简化复杂图表创建，可以与pandas很好的集成。</p>
<h3 id="简易用法"><a href="#简易用法" class="headerlink" title="简易用法"></a>简易用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns <span class="comment">#一旦导入了seaborn，matplotlib的默认作图风格就会被覆盖成seaborn的格式</span></div><div class="line">%matplotlib inline </div><div class="line"><span class="comment">#在jupyter notebook里作图，需要用到这个命令</span></div></pre></td></tr></table></figure>
<h4 id="读取原始数据（这是一份红酒成分与口感评分数据）"><a href="#读取原始数据（这是一份红酒成分与口感评分数据）" class="headerlink" title="读取原始数据（这是一份红酒成分与口感评分数据）"></a>读取原始数据（这是一份红酒成分与口感评分数据）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">winedata=pd.read_csv(<span class="string">'winequality-red.csv'</span>)</div><div class="line">winedata.head()</div></pre></td></tr></table></figure>
<p><img src="/images/winedata.png" alt="png"></p>
<h4 id="直方图——seaborn-distplot"><a href="#直方图——seaborn-distplot" class="headerlink" title="直方图——seaborn.distplot()"></a><strong>直方图</strong>——seaborn.distplot()</h4><p>如对上面的quality列做直方图，保留概率密度曲线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sns.distplot(winedata[<span class="string">'quality'</span>])   <span class="comment"># 不需要概率密度曲线直接将 kde=False 即可</span></div><div class="line">sns.set_style(<span class="string">'dark'</span>)    <span class="comment">#设置背景色</span></div><div class="line">sns.utils.axlabel(<span class="string">'Quality'</span>, <span class="string">'Frequency'</span>) <span class="comment">#设置X,Y坐标名</span></div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/images/output_5_0.png" alt="png"></p>
<h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sns.factorplot(data=winedata, x=<span class="string">'quality'</span>, y=<span class="string">'total sulfur dioxide'</span>,size=<span class="number">3</span>)</div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/output_7_0.png" alt="png"></p>
<h4 id="柱状图——seaborn-barplot"><a href="#柱状图——seaborn-barplot" class="headerlink" title="柱状图——seaborn.barplot()"></a>柱状图——seaborn.barplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sns.factorplot(data=winedata, x=<span class="string">'quality'</span>, y=<span class="string">'total sulfur dioxide'</span>,kind=<span class="string">'bar'</span>,size=<span class="number">3</span>)</div><div class="line"><span class="comment">#ax = sns.barplot(data=winedata, x='quality', y='total sulfur dioxide',ci=0)</span></div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/output_9_0.png" alt="png"></p>
<h4 id="散点图——seaborn-stripplot"><a href="#散点图——seaborn-stripplot" class="headerlink" title="散点图——seaborn.stripplot()"></a>散点图——seaborn.stripplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">temp=sns.FacetGrid(winedata, hue=<span class="string">'quality'</span>, size=<span class="number">3</span>)   <span class="comment">#hue参数设置区分色彩列</span></div><div class="line">temp.map(plt.scatter, <span class="string">'volatile acidity'</span>, <span class="string">'alcohol'</span>)</div><div class="line">temp.add_legend()</div><div class="line">sns.plt.show()</div><div class="line"><span class="comment">#ax = sns.stripplot(x='quality', y='alcohol', data=winedata) #普通散点图</span></div><div class="line"><span class="comment">#ax = sns.stripplot(x='quality', y='alcohol', data=winedata, jitter=True) #带抖动的散点图</span></div><div class="line"><span class="comment">#sns.plt.show()</span></div></pre></td></tr></table></figure>
<p><img src="/images/output_11_0.png" alt="png"></p>
<h4 id="箱型图——seaborn-boxplot"><a href="#箱型图——seaborn-boxplot" class="headerlink" title="箱型图——seaborn.boxplot()"></a>箱型图——seaborn.boxplot()</h4><p>以quality为X轴，alcohol为Y轴，做出箱线图，可以看出异常值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ax=sns.boxplot(x=<span class="string">'quality'</span>, y=<span class="string">'alcohol'</span>, data=winedata)</div><div class="line">ax=sns.stripplot(x=<span class="string">'quality'</span>, y=<span class="string">'alcohol'</span>, data=winedata, jitter=<span class="keyword">True</span>, color=<span class="string">'.3'</span>)  <span class="comment">#加上点，jitter=True 使各个散点分开，要不然会是一条直线</span></div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/images/output_13_0.png" alt="png"></p>
<h4 id="小提琴图——seaborn-violinplot"><a href="#小提琴图——seaborn-violinplot" class="headerlink" title="小提琴图——seaborn.violinplot()"></a>小提琴图——seaborn.violinplot()</h4><p>可以看出密度分布<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ax = sns.violinplot(x=<span class="string">'quality'</span>, y=<span class="string">'alcohol'</span>, data=winedata, size=<span class="number">5</span>)</div><div class="line">ax = sns.swarmplot(x=<span class="string">'quality'</span>, y=<span class="string">'alcohol'</span>, data=winedata,color=<span class="string">'.9'</span>)</div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/images/output_15_0.png" alt="png"></p>
<h4 id="多变量作图——seaborn-pairplot"><a href="#多变量作图——seaborn-pairplot" class="headerlink" title="多变量作图——seaborn.pairplot()"></a>多变量作图——seaborn.pairplot()</h4><p>seaborn可以一次性两两组合多个变量做出多个对比图，有n个变量，就会做出一个n × n个格子的图，相同的两个变量之间以直方图展示，不同的变量则以散点图展示，<strong>要注意的是数据中不能有NaN（缺失的数据），否则会报错。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sns.pairplot(winedata, vars=[<span class="string">'quality'</span>, <span class="string">'residual sugar'</span>,<span class="string">'alcohol'</span>],hue=<span class="string">'quality'</span>)</div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/images/output_17_0.png" alt="png"></p>
<h4 id="回归图——seaborn-lmplot-、seaborn-regplot"><a href="#回归图——seaborn-lmplot-、seaborn-regplot" class="headerlink" title="回归图——seaborn.lmplot()、seaborn.regplot()"></a>回归图——seaborn.lmplot()、seaborn.regplot()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sns.lmplot(x=<span class="string">'volatile acidity'</span>, y=<span class="string">'alcohol'</span>, data=winedata)   <span class="comment"># hue参数进行分组拟合，markers=['o', 'x']，col参数不同组的子图</span></div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure>
<p><img src="/images/output_19_0.png" alt="png"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sns.regplot(x=<span class="string">'fixed acidity'</span>, y=<span class="string">'alcohol'</span>, data=winedata)</div><div class="line">sns.plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/images/output_20_0.png" alt="png"></p>
<p><a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="external">更多用法参考官方手册</a><br>点这查看本文<a href="https://github.com/phoebepx/normally-accumulate/blob/master/learn_seaborn.ipynb" target="_blank" rel="external">.ipynb文件</a>，欢迎纠错~</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;EDA过程中，想要更了解你的数据，选择一个合适的可视化工具，可以说会让你的工作事半功倍。&lt;br&gt;本文主要介绍一个以matplotlib作为底层，更易上手的作图库&lt;code&gt;seaborn&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Data Visualization" scheme="http://phoebepan.cn/categories/Data-Visualization/"/>
    
    
      <category term="ML，Visualization" scheme="http://phoebepan.cn/tags/ML%EF%BC%8CVisualization/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记——7 Techniques to Handle Imbalanced Data</title>
    <link href="http://phoebepan.cn/2017/06/05/Imbalanced_data/"/>
    <id>http://phoebepan.cn/2017/06/05/Imbalanced_data/</id>
    <published>2017-06-05T07:30:16.000Z</published>
    <updated>2017-06-05T14:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这篇阅读笔记，主要介绍处理不平衡数据的常见7种方法。所谓<strong>不平衡数据</strong>，指在网络入侵、癌症监测、银行信用卡检测等领域，出现如下图所示的数据集中，正负样本比例严重失调的情况。<br><img src="/images/imbalanced-data-1.png" alt="imbalanced-data-1" title="正负样本分布"></p>
</blockquote>
<a id="more"></a>
<p><a href="http://www.kdnuggets.com/2017/06/7-techniques-handle-imbalanced-data.html" target="_blank" rel="external">博客中</a>介绍了7种方法帮助我们训练一个分类器，来处理这些不平衡的数据。</p>
<h3 id="1-使用正确的评价指标"><a href="#1-使用正确的评价指标" class="headerlink" title="1.使用正确的评价指标"></a>1.使用正确的评价指标</h3><p>针对上图这样的数据集，如果我们还是采用准确度(accuracy)来评估模型训练结果，那么所有的分类器将所有的测试样本都分到“0”这一类，模型准确率无疑非常好，但显然，这样的model对我们来说，是没有价值的。<br>这种情况，其他适宜的评估指标有：<code>Precision/Specificity</code>、<code>Recall/Sensitivity</code>、<code>F1 score</code>、<code>MCC</code>、<code>AUC</code>、<code>G-Mean</code></p>
<h3 id="2-训练集重新采样-Resample"><a href="#2-训练集重新采样-Resample" class="headerlink" title="2.训练集重新采样(Resample)"></a>2.训练集重新采样(Resample)</h3><p>除了使用不同的评价指标，另外可以通过<strong>下采样</strong>和<strong>过采样</strong>在不平衡数据中得到平衡数据集。</p>
<h4 id="下采样-Under-sampling"><a href="#下采样-Under-sampling" class="headerlink" title="下采样(Under-sampling)"></a>下采样(Under-sampling)</h4><p>当数据量充足时，下采样通过减少负样本数量（即多数的类），即保留正样本和随机选择相同数量的负样本，得到新的平衡训练集。</p>
<h4 id="过采样-Over-sampling"><a href="#过采样-Over-sampling" class="headerlink" title="过采样(Over-sampling)"></a>过采样(Over-sampling)</h4><p>当数据量不够时，过采样通过增加正样本数来平衡数据集，可以采用<code>repetition</code>、<code>bootstrapping</code>、<code>SMOTE</code>得到新的正样本。<br><a href="https://github.com/scikit-learn-contrib/imbalanced-learn" target="_blank" rel="external">Python实现</a></p>
<p>下采样和过采样两者之间没有谁优谁劣，具体用哪种方式取决于数据集本身，有时两者结合使用可能效果更好。</p>
<h3 id="3-正确使用K折交叉验证"><a href="#3-正确使用K折交叉验证" class="headerlink" title="3.正确使用K折交叉验证"></a>3.正确使用K折交叉验证</h3><p>值得注意的是，当我们用过采样处理不平衡训练集时，通常需要在<strong>过采样之前应用交叉验证</strong>，这样做的好处就是避免模型过拟合。</p>
<h4 id="过拟合产生原因："><a href="#过拟合产生原因：" class="headerlink" title="过拟合产生原因："></a>过拟合产生原因：</h4><ul>
<li>模型的复杂度越高，越容易overfitting</li>
<li>数据的噪声越大，越容易overfitting</li>
<li>数据量越少，越容易overfitting</li>
</ul>
<h3 id="4-重采样训练集集成-Ensemble"><a href="#4-重采样训练集集成-Ensemble" class="headerlink" title="4.重采样训练集集成(Ensemble)"></a>4.重采样训练集集成(Ensemble)</h3><p><img src="/images/imbalanced-data-2.png" alt="imbalanced-data-2" title="Ensemble different resampled datasets"><br>如上面示例图所示，使用所有的正样本和 n 个不同的负样本建立 n 个models。比如你想得到10个models，如果正样本是1000个，那么你需要随机选择10000个负样本，然后将这10000个负样本分成10份，接下来训练这10个不同的models。<br>这种方法，简单方便，易扩展，更好的泛化能力。</p>
<h3 id="5-不同比例采样"><a href="#5-不同比例采样" class="headerlink" title="5.不同比例采样"></a>5.不同比例采样</h3><p>之前的方法，都是1:1调和样本，最佳的比例取决于数据和使用的模型。与其对所有models使用同样的比例进行ensemble，更值得尝试的是采用不同的比例进行ensemble。正如下图所示：<br><img src="/images/imbalanced-data-3.png" alt="imbalanced-data-3" title="Resample with different ratios"></p>
<h3 id="6-负样本进行聚类"><a href="#6-负样本进行聚类" class="headerlink" title="6.负样本进行聚类"></a>6.负样本进行聚类</h3><p>Sergey在Quora上提出一个更完美的<a href="www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set/answers/1144228?srid=h3G6o">方法</a>，对负样本进行聚类，只用负样本聚类的簇中心和正样本组成训练集。</p>
<h3 id="7-自己设计模型"><a href="#7-自己设计模型" class="headerlink" title="7.自己设计模型"></a>7.自己设计模型</h3><p>事实上，已经有一些models本身就可以处理非平衡数据集，无需进行重新采样，如XGBoost。<br>重设损失函数，比起负样本误分，对正样本误分设置更大的惩罚系数。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这些处理方法只是一个起点，没有一种方法可以解决所有问题，<code>多试才是王道</code>！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这篇阅读笔记，主要介绍处理不平衡数据的常见7种方法。所谓&lt;strong&gt;不平衡数据&lt;/strong&gt;，指在网络入侵、癌症监测、银行信用卡检测等领域，出现如下图所示的数据集中，正负样本比例严重失调的情况。&lt;br&gt;&lt;img src=&quot;/images/imbalanced-data-1.png&quot; alt=&quot;imbalanced-data-1&quot; title=&quot;正负样本分布&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://phoebepan.cn/categories/Machine-Learning/"/>
    
    
      <category term="ML，Reading" scheme="http://phoebepan.cn/tags/ML%EF%BC%8CReading/"/>
    
  </entry>
  
  <entry>
    <title>充实的无话可说</title>
    <link href="http://phoebepan.cn/2017/05/15/fine_life/"/>
    <id>http://phoebepan.cn/2017/05/15/fine_life/</id>
    <published>2017-05-15T07:30:16.000Z</published>
    <updated>2017-06-04T02:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有人说，人生有两大遗憾，太晚谈恋爱，太早读经典。读懂一本书，看懂一部电影和谈对一场恋爱，都需要刚刚好的时间。太早理解不了，太晚就少了份陪伴感。</p>
</blockquote>
<a id="more"></a>
<h3 id="碎碎念1"><a href="#碎碎念1" class="headerlink" title="碎碎念1"></a><center>碎碎念1</center></h3><blockquote>
<p>好朋友问我，嘿，最近怎么不见你出去浪了呢，端午打算去哪耍去？<br>我笑着答道，宅家看书。<br>朋友诡异的看着我说，不是吧，学霸真可怕！</p>
</blockquote>
<p>回想年后这几个月自己的转变还真是蛮大的，从以前放荡自由的野孩子，变得像点研究僧的模样，而且越来越喜欢这样自律的自己。<br>研一的周末，要么在研究烘焙，要么参加户外活动，认识了很多有意思的朋友，相比较单调的校园生活，可以说外面的世界太精彩，一次次被惊艳，看着他们活出自己理想生活状态，可以说是非常羡慕。然而渐渐我发现，如果自己不够优秀，认识再多的人，你的生活也不会有所改变。现在的我，学着跟自己和平相处，控制情绪，学着量化每天的时间，每天有小目标，生活得很充实。</p>
<h3 id="碎碎念2"><a href="#碎碎念2" class="headerlink" title="碎碎念2"></a><center>碎碎念2</center></h3><p>现在的我，每天不管多忙，多晚，也要读几页书，读书，可以说是一种自嗨的事儿，一旦这样的自嗨能力养成了，你就不容易陷入无聊，不容易被别人的想法左右。<br>人只能活一次，没有可以对标的人生，上一辈的建议有时过气，同龄人其实也一样迷茫，而读书就不一样了，只要你尝试阅读不同的书，你就可以尝试不同的人生，体验不同的精彩生活，重回现实，你会活的更明白。<br>平淡的日子，不急不躁，继续丰盈自己~</p>
<p><img src="/images/Shawshank_Redemption.jpg" alt="肖申克的救赎" title="The Shawshank Redemption"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;有人说，人生有两大遗憾，太晚谈恋爱，太早读经典。读懂一本书，看懂一部电影和谈对一场恋爱，都需要刚刚好的时间。太早理解不了，太晚就少了份陪伴感。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://phoebepan.cn/categories/Thinking/"/>
    
    
      <category term="Thinking" scheme="http://phoebepan.cn/tags/Thinking/"/>
    
      <category term="Life" scheme="http://phoebepan.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Modern Machine Learning Algorithms:Strengths and Weaknesses(阅读笔记)</title>
    <link href="http://phoebepan.cn/2017/05/13/ML_good_weak/"/>
    <id>http://phoebepan.cn/2017/05/13/ML_good_weak/</id>
    <published>2017-05-13T07:30:16.000Z</published>
    <updated>2017-06-02T14:34:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><center><strong>推荐理由</strong></center><br>对于机器学习算法的盘点，网上有很多。但本文亮点在于结合使用场景来把问题说明白，作者结合他的实际经验，细致剖析每种算法在实践中的优势和不足。</p>
</blockquote>
<a id="more"></a>
<p>当前的「三大」最常见的机器学习任务：</p>
<ul>
<li>回归（Regression）</li>
<li>分类（Classification）</li>
<li>聚类（Clustering）</li>
</ul>
<p>下面是我阅读这篇文章后总结的的思维导图：<br><img src="/images/whole.png" alt="机器学习3大任务" title="机器学习3大任务"><br><img src="/images/regression1.png" alt="回归"><br><img src="/images/regression2.png" alt="回归" title="回归"><br><img src="/images/classfication1.png" alt="分类"><br><img src="/images/classfication2.png" alt="分类" title="分类"><br><img src="/images/cocluster1.png" alt="聚类"><br><img src="/images/cocluster2.png" alt="聚类" title="聚类"><br>最后，<a href="https://elitedatascience.com/machine-learning-algorithms" target="_blank" rel="external">附原文链接</a>，欢迎纠错。<br><blockquote class="blockquote-center"><p>Of course, the algorithms you try must be appropriate for your problem, which is where picking the right machine learning task comes in.</p>
</blockquote></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;center&gt;&lt;strong&gt;推荐理由&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;对于机器学习算法的盘点，网上有很多。但本文亮点在于结合使用场景来把问题说明白，作者结合他的实际经验，细致剖析每种算法在实践中的优势和不足。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://phoebepan.cn/categories/Machine-Learning/"/>
    
    
      <category term="ML" scheme="http://phoebepan.cn/tags/ML/"/>
    
      <category term="Reading" scheme="http://phoebepan.cn/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Pandas杂碎</title>
    <link href="http://phoebepan.cn/2017/05/12/pandas/"/>
    <id>http://phoebepan.cn/2017/05/12/pandas/</id>
    <published>2017-05-12T07:30:16.000Z</published>
    <updated>2017-05-29T05:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文主要是平时运用Pandas的小积累，涉及到读写文件，格式转换、缺失值填充，简单统计等多个方面。</p>
</blockquote>
<a id="more"></a>
<h3 id="读写csv文件到DataFrame"><a href="#读写csv文件到DataFrame" class="headerlink" title="读写csv文件到DataFrame"></a>读写csv文件到DataFrame</h3><p><code>df=pd.read_csv(&#39;filename&#39;,encoding=&#39;utf-8&#39;)</code><br>读入csv文本，编码为utf-8<br><code>df.to_csv(&#39;filename&#39;,sep=&#39;\t&#39;,index=False)</code><br>‘\t’切分df，写入csv，不包含行索引</p>
<h3 id="格式转换、值填充、删除"><a href="#格式转换、值填充、删除" class="headerlink" title="格式转换、值填充、删除"></a>格式转换、值填充、删除</h3><p> <code>df.to_dict(outtype=&#39;dict&#39;)</code><br>将DataFrame转换成其他结构类型，outtype的参数为‘dict’、‘list’、‘series’和‘records’<br> <code>df[&#39;A&#39;].astype(float)</code><br>将DataFrame的A列类型更改成float<br><code>df.rename(columns={&#39;oldname&#39;: &#39;newname&#39;}, inplace=True)</code>   #修改列名<br><code>df.fillna(0)</code>  #NaN用0填充，处理缺失值<br><code>df.drop_duplicates(subset=[&#39;A&#39;]，keep=&#39;first&#39;)</code><br>按A列去重，保留第一行，keep（’first’,’last’,False）</p>
<h3 id="查看DataFrame概要"><a href="#查看DataFrame概要" class="headerlink" title="查看DataFrame概要"></a>查看DataFrame概要</h3><p><code>df.head()</code>     #前几行<br><code>df.tail()</code>     #末几行<br><code>df.index</code>      #行标签<br><code>df.columns</code>    #列标签<br><code>df.dtypes</code>     #每一列数据类型<br><code>df[&#39;column&#39;].count()</code>    #column列非空条数<br><code>df[&#39;column&#39;].isnull()</code>   #column列是否有NaN的数据<br><code>df[&#39;column&#39;].unique()</code>    #column列所有值</p>
<h3 id="简单统计"><a href="#简单统计" class="headerlink" title="简单统计"></a>简单统计</h3><p><code>df.describe()</code>   #各列基本描述统计值<br><code>df[&#39;A&#39;].value_counts()</code>  #计算A列每个值的频率</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>df.sort_index(axis=1,ascending=False)</code><br>对DataFrame的axis=0(行)，1(列)索引排序（ascending=True(升)，False(降)）<br><code>df.sort_index(by=[&#39;A&#39;, &#39;B&#39;], ascending=[True, False])</code>&lt;==&gt;<code>df.sort_values(by=[&#39;A&#39;, &#39;B&#39;], ascending=[True, False])</code>&lt;==&gt;<code>df.sort(columns=[&#39;A&#39;,&#39;B&#39;],ascending=[1,0])</code><br>对DataFrame先按’A’升排序, 再按’B’降排序</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>df.groupby(subset=[&#39;A&#39;,&#39;B&#39;],as_index=True)</code>    #以列A，B对df进行分组，默认A，B作为分组索引<br><code>df.groupby(by=[&#39;A&#39;],as_index=True).get_group(&#39;a&#39;)</code> #按A列分组后获取’a’组<br><code>df.groupby([&#39;col1&#39;,&#39;col2&#39;]).size().to_frame(name =&#39;count&#39;)</code><br>&lt;==&gt;<code>df.groupby([&#39;col1&#39;,&#39;col2&#39;]).size().reset_index(name =&#39;count&#39;)</code><br>按col1,col2对df进行分组，<code>size()</code>统计每一分组成员个数(<code>count()</code>也可以，<a href="https://stackoverflow.com/documentation/pandas/1822/grouping-data/6874/aggregating-by-size-and-count#t=201607220906502658034" target="_blank" rel="external">区别</a>就是count()过滤了NaN，size()包含)，命名为’count’</p>
<h3 id="选择DataFrame行列"><a href="#选择DataFrame行列" class="headerlink" title="选择DataFrame行列"></a>选择DataFrame行列</h3><p><a href="http://www.shanelynn.ie/select-pandas-dataframe-rows-and-columns-using-iloc-loc-and-ix/" target="_blank" rel="external">示例参考</a><br><code>df.iloc[&lt;row selection&gt;,&lt;col selection&gt;]</code>  #基于行列索引选择（Selecting rows by label/index）<br><code>df.loc[&lt;row selection&gt;,&lt;col selection&gt;]</code>   #基于条件选择（Selecting rows with a boolean / conditional lookup）<br><code>ix[]</code>  #索引，条件混合选择</p>
<p><code>df[df[&#39;A&#39;].isin(li)]</code>  #选择A列值在列表li中的行<br><code>df.saple(n=3)</code> #随机抽取3行数据，</p>
<h3 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from sklearn import preprocessing</div><div class="line">df=preprocessing.scale(df,axis=0)   #df每一个feature归一化(列)</div><div class="line">df=preprocessing.scale(df,axis=1)   #df每一个sample归一化(行)</div></pre></td></tr></table></figure>
<h3 id="离散特征one-hot编码"><a href="#离散特征one-hot编码" class="headerlink" title="离散特征one-hot编码"></a>离散特征one-hot编码</h3><p><code>df = pd.get_dummies(df[&#39;A&#39;], prefix=&#39;A&#39;)</code>  #对A列重新编码，编码后的列前缀加上’A’<br><code>df = pd.get_dummies(df)</code>   #对df所有离散特征进行one-hot编码</p>
<h3 id="合并——merge、concat、append"><a href="#合并——merge、concat、append" class="headerlink" title="合并——merge、concat、append"></a>合并——merge、concat、append</h3><p><code>df1.append(df2,ignore_index=True)</code> #在df1下面追加df2，行索引重排序<br><code>pd.concat([df1[&#39;A&#39;],df2],axis=1)</code>  #列方向合并<br><code>pd.merge(df1, df2, how=&#39;inner&#39;, on=None, left_on=None, right_on=None,left_index=False, right_index=False)</code><br>how=[‘inner’,’left’,’right’,’outer’]对应内，左，右，外连接,on指定连接key</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;本文主要是平时运用Pandas的小积累，涉及到读写文件，格式转换、缺失值填充，简单统计等多个方面。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
      <category term="pandas" scheme="http://phoebepan.cn/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python实现大文件分割</title>
    <link href="http://phoebepan.cn/2017/04/25/split_bigtxt/"/>
    <id>http://phoebepan.cn/2017/04/25/split_bigtxt/</id>
    <published>2017-04-25T07:30:16.000Z</published>
    <updated>2017-06-04T23:59:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近处理数据，碰到有一个按行存储的文本文件，含有七百多万条数据，大小近7G，本地直接报出<code>MemoryError</code>，处理不了。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>用python写个脚本，将大文件拆分成小文件，对小文件进行处理，问题不就解决了么。</p>
</blockquote>
<a id="more"></a>
<h3 id="分割脚本"><a href="#分割脚本" class="headerlink" title="分割脚本"></a>分割脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(fromfile,todir,chunksize=<span class="number">22</span>*<span class="number">10000</span>)</span>:</span></div><div class="line">	<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(todir):<span class="comment">#check whether todir exists or not</span></div><div class="line">        os.mkdir(todir)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(todir):</div><div class="line">            os.remove(os.path.join(todir,fname))</div><div class="line">    partnum = <span class="number">0</span></div><div class="line">    inputfile = open(fromfile,<span class="string">'rb'</span>)<span class="comment">#open the fromfile</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        partnum += <span class="number">1</span></div><div class="line">        filename = os.path.join(todir,(<span class="string">'part-%04d'</span> %partnum))</div><div class="line">        fileobj = open(filename,<span class="string">'wb'</span>)<span class="comment">#make partfile</span></div><div class="line">        linenum = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span>( linenum&lt;= batchSize ):</div><div class="line">            read_content = inputfile.readline()</div><div class="line">            <span class="keyword">if</span>( read_content ):</div><div class="line">                fileobj.write(read_content)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">            linenum += <span class="number">1</span></div><div class="line">        fileobj.close()</div><div class="line">        <span class="keyword">if</span> (linenum &lt; batchSize): <span class="comment">#last part file</span></div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> partnum</div></pre></td></tr></table></figure>
<p>上面的脚本，就能够就将大文件，分割成小文件，且每个小文件含有220001行记录，大小约为178M，在todir目录看到分割后的文件如下：<br><img src="/images/partfile.png" alt="partfile" title="分割后部分文件"></p>
<p>欢迎大神，推荐更棒的方法！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;最近处理数据，碰到有一个按行存储的文本文件，含有七百多万条数据，大小近7G，本地直接报出&lt;code&gt;MemoryError&lt;/code&gt;，处理不了。&lt;/p&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h3&gt;&lt;p&gt;用python写个脚本，将大文件拆分成小文件，对小文件进行处理，问题不就解决了么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>魔力Python——pickle持久化对象</title>
    <link href="http://phoebepan.cn/2017/04/22/pickle/"/>
    <id>http://phoebepan.cn/2017/04/22/pickle/</id>
    <published>2017-04-22T07:30:16.000Z</published>
    <updated>2017-06-02T23:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><center><strong>简介</strong></center><br>本文主要介绍Python pickle模块的用法，实例分析<code>pickle</code>模块的功能与相关适用技巧。<code>pickle</code>提供了一个简单的<strong>持久化</strong>功能，可以将对象以文件的形式存放在磁盘上，方便多次读取与共享。</p>
</blockquote>
<a id="more"></a>
<h3 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h3><h4 id="pickle-dump-obj-file-protocol"><a href="#pickle-dump-obj-file-protocol" class="headerlink" title="pickle.dump(obj,file[,protocol])"></a>pickle.dump(obj,file[,protocol])</h4><p>这条语句序列化对象obj，并将结果数据流写入到文件file中。可选参数protocol是序列化模式，默认为0，表示以文本形式序列化，如果设置为 1 或 True，则以高压缩的二进制格式保存序列化后的对象，否则以ASCII格式保存。</p>
<h4 id="pickle-load-file"><a href="#pickle-load-file" class="headerlink" title="pickle.load(file)"></a>pickle.load(file)</h4><p>反序列化对象，将文件中的数据解析为一个python对象。</p>
<h3 id="基本用例"><a href="#基本用例" class="headerlink" title="基本用例"></a>基本用例</h3><p>下面这段代码，实现将4维矩阵obj对象持久化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pickle</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'./test.pkl'</span>):    <span class="comment">#当前路径下是否已经存在序列化的test.pkl</span></div><div class="line">    obj=pickle.load(open(<span class="string">'./test.pkl'</span>,<span class="string">'rb'</span>))    <span class="comment">#如果已经存在直接load</span></div><div class="line"><span class="keyword">else</span>:   <span class="comment">#否则，将4维矩阵序列化到存储到当前路径下的test.pkl中</span></div><div class="line">    obj = np.ones((<span class="number">4</span>,<span class="number">4</span>))    </div><div class="line">    pickle.dump(obj,open(<span class="string">'./test.pkl'</span>,<span class="string">'wb'</span>))</div><div class="line">print(obj)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;center&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;本文主要介绍Python pickle模块的用法，实例分析&lt;code&gt;pickle&lt;/code&gt;模块的功能与相关适用技巧。&lt;code&gt;pickle&lt;/code&gt;提供了一个简单的&lt;strong&gt;持久化&lt;/strong&gt;功能，可以将对象以文件的形式存放在磁盘上，方便多次读取与共享。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>初涉MapReduce</title>
    <link href="http://phoebepan.cn/2017/04/21/MapReduce/"/>
    <id>http://phoebepan.cn/2017/04/21/MapReduce/</id>
    <published>2017-04-21T07:30:16.000Z</published>
    <updated>2017-05-31T23:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>了解一件事是什么，可以帮助了解它不是什么。</p>
</blockquote>
<a id="more"></a>
<h3 id="产生根源"><a href="#产生根源" class="headerlink" title="产生根源"></a><center>产生根源</center></h3><p>解决大数据分布式存储、运算容错性问题。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><center>原理</center></h3><p>MapReduce是一种算法和框架。Hadoop是MapReduce的开源实现。使用MapReduce需要两个函数，一个<strong>mapper函数</strong>，一个<strong>reducer函数</strong>，mapper函数将每个数据点作为输入，按排序输出形如（键，值）这样的二元组列表，然后框架会使用定向冒泡排序对输出排序，如果键相同，合并两个二元组。这些二元组会被送往执行reducer函数的机器，reducer函数使用聚合函数对值进行聚合，得到新的值，输出新的（键，新值）列表。</p>
<p><img src="/images/mapreduce.png" alt="示例图" title="抽象原理图"></p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><center>适用场景</center></h3><p>能用MapReduce解决的问题有一个重要特征：数据可以被分布存储到各个计算机上，且算法可以在每台计算机上独立处理数据，即每台计算机之间是相互隔离的，他们不需要知道其他机器在处理什么。MapReduce<strong>不适合迭代式的算法</strong>，所谓迭代式算法就是，上一次的输出作为下一次的输入，这样的算法。</p>
<p><a href="http://blog.jobbole.com/1321/" target="_blank" rel="external">加深理解，请看这篇博文！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;了解一件事是什么，可以帮助了解它不是什么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Architecture" scheme="http://phoebepan.cn/categories/Architecture/"/>
    
    
      <category term="MapReduce" scheme="http://phoebepan.cn/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>并行化——multiprocessing</title>
    <link href="http://phoebepan.cn/2017/04/19/multiprocessing/"/>
    <id>http://phoebepan.cn/2017/04/19/multiprocessing/</id>
    <published>2017-04-19T07:30:16.000Z</published>
    <updated>2017-06-02T00:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><code>multiprocessing</code>是Python的标准模块，它既可以用来编写多进程，也可以用来编写多线程。<code>multiprocessing.dummy</code>实现多线程，<code>multiprocessing</code>实现多进程，本文主要介绍多进程的用法。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><center>问题</center></h3><p>最近在处理疾病数据时，遇到这样一个问题，需要计算同构的2000个文档加和平均值，为提高处理效率，使用<code>multiprocessing</code>库进行并行化，在此记录下。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><center>用法</center></h3><p><code>multiprocessing.pool</code>能自动管理进程任务，通过下面的语句初始化有10个进程数的pool，若<code>Pool()</code>未指定进程数，那么使用os.cpu_count()返回的数量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line">processNum = <span class="number">10</span></div><div class="line">p = Pool(processNum)</div></pre></td></tr></table></figure></p>
<p>假定我们需要并行执行的任务是如下函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(parameter)</span>:</span></div><div class="line">    <span class="comment"># do something</span></div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure></p>
<p>主函数调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">results = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(processNum):</div><div class="line">    result = p.apply_async(func, args=(i,))</div><div class="line">    results.append(result)</div></pre></td></tr></table></figure></p>
<p><code>p.apply_async</code>采用异步方式调用函数func，<code>p.apply</code>采用同步方式调用，即串行方式，下一个func要等待上一个func运行完成才开始运行。针对我的问题，只需要异步操作即可。<br>最后，使用以下语句回收进程池：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure></p>
<h3 id="附上完成使用代码"><a href="#附上完成使用代码" class="headerlink" title="附上完成使用代码"></a>附上完成使用代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line">processNum = <span class="number">10</span></div><div class="line">p = Pool(processNum)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(parameter)</span>:</span></div><div class="line">    <span class="comment"># do something</span></div><div class="line">    <span class="keyword">return</span> result</div><div class="line">results = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(processNum):</div><div class="line">    result = p.apply_async(func, args=(i,))</div><div class="line">    results.append(result)</div><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;code&gt;multiprocessing&lt;/code&gt;是Python的标准模块，它既可以用来编写多进程，也可以用来编写多线程。&lt;code&gt;multiprocessing.dummy&lt;/code&gt;实现多线程，&lt;code&gt;multiprocessing&lt;/code&gt;实现多进程，本文主要介绍多进程的用法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
      <category term="Parallelization" scheme="http://phoebepan.cn/tags/Parallelization/"/>
    
  </entry>
  
  <entry>
    <title>Linux——后台运行、查看和关闭</title>
    <link href="http://phoebepan.cn/2017/04/17/linux_backstage/"/>
    <id>http://phoebepan.cn/2017/04/17/linux_backstage/</id>
    <published>2017-04-17T07:30:16.000Z</published>
    <updated>2017-05-29T04:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>用Xshell/ssh登录了Linux服务器，运行一些耗时长的程序，结果不小心断网了，白白花了时间却没出结果。如何让命令提交不受本地关闭终端、断网等干扰呢？</p>
</blockquote>
<blockquote class="blockquote-center"><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>让进程在后台运行，相关命令：<code>&amp;、nohup、jobs、fg、ctrl+z、bg、ctrl+c、kill</code></p>
</blockquote>
<a id="more"></a>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>命令末尾加上&amp;，相当于把这条命令放在后台执行，如：<code>python3.4 test.py &amp;</code></p>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>若想要终端关闭，程序依旧执行，nohup无疑是首选方式，用法：<code>nohup &lt;command&gt; &amp;</code></p>
<h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>查看当前在后台运行的命令状态，<code>jobs -l</code>可显示所有任务得PID</p>
<h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p>后台命令调入前台运行。用法：<code>fg %jobnumber</code>（jobnumber通过<code>jobs</code>命令查看）</p>
<h3 id="ctrl-z"><a href="#ctrl-z" class="headerlink" title="ctrl+z"></a>ctrl+z</h3><p>可以将一个正在前台运行的命令放入后台，并处于暂停状态</p>
<h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>后台暂停的命令，变成在后台继续执行，用法：<code>bg %jobnumber</code></p>
<h3 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl+c"></a>ctrl+c</h3><p>前台终止进程</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>终止后台进程继续运行，</p>
<ul>
<li>通过job号，执行：<code>kill %jobnumber</code></li>
<li><code>ps xw</code>查看进程号(PID)，执行：<code>kill PID</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;用Xshell/ssh登录了Linux服务器，运行一些耗时长的程序，结果不小心断网了，白白花了时间却没出结果。如何让命令提交不受本地关闭终端、断网等干扰呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;p&gt;让进程在后台运行，相关命令：&lt;code&gt;&amp;amp;、nohup、jobs、fg、ctrl+z、bg、ctrl+c、kill&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Daily Accumulation" scheme="http://phoebepan.cn/categories/Daily-Accumulation/"/>
    
    
      <category term="linux" scheme="http://phoebepan.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《新商业文明》摘录</title>
    <link href="http://phoebepan.cn/2017/04/16/New%20Commercial%20civilization/"/>
    <id>http://phoebepan.cn/2017/04/16/New Commercial civilization/</id>
    <published>2017-04-16T07:30:16.000Z</published>
    <updated>2017-05-29T05:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a><center>作者简介</center></h3><p>乌麦尔·哈克，全球领先的管理思想家，被Thinkers 50评为全球最具影响力的管理学家之一。在《哈佛商业评论》的博客上发表多篇文章，主要关注领域为经济、领导力、创新等。</p>
<h3 id="本书核心"><a href="#本书核心" class="headerlink" title="本书核心"></a><center>本书核心</center></h3><p>《新商业文明：从利润到价值》，这本书勾画了一幅未来商业的蓝图，在这样的商业图景下，企业被顾客所爱戴，被竞争者所羡慕，被所有关心我们这个星球未来的人们所尊重。旧商业文明关注利润和股东利益最大化，新商业文明格局下企业更关注与社会、顾客、员工、环境的关系。企业为追求发展，以牺牲环境、社会、大众、后代利益为代价，获得高额利润的同时，却忽略了商业精神的实质。作者本书中提到，商业精神的内涵是企业应该掌握“建设型优势”，即关注真实的价值创造而非仅仅关注股东利益，这要求企业做到几个转变：从价值链到价值循环，从价值主张到价值对话，从战略到哲学，从市场保护到市场完善，从产品到幸福，从盲目增长到智慧增长。基于建设型优势，企业将成为有责任、有担当、有领导力的组织，而一种具备更长远、更开放视角的新商业文明也将形成。</p>
</blockquote>
<a id="more"></a>
<h3 id="脉络"><a href="#脉络" class="headerlink" title="脉络"></a><center>脉络</center></h3><p><img src="/images/New Commercial civilization.jpg" width="150%" height="70%" align="center/"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a><center>对比</center></h3><table>
<thead>
<tr>
<th style="text-align:left">比较竞争优势来源</th>
<th style="text-align:center">建设型优势来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>成本优势：</strong>来自攫取资源的价值链，直至资源耗尽</td>
<td style="text-align:center"><strong>损耗优势：</strong>来自可以使资源再生、废物得到利用的循环价值体系</td>
</tr>
<tr>
<td style="text-align:left"><strong>品牌：</strong>传达单方价值主张所带来的利益</td>
<td style="text-align:center"><strong>响应性：</strong>流动的、不间断的、多方面价值对话</td>
</tr>
<tr>
<td style="text-align:left"><strong>市场主导：</strong>通过战略魔化阻止竞争发生的零和游戏</td>
<td style="text-align:center">弹性：通过持久运营哲学在竞争中逐渐产生的优势</td>
</tr>
<tr>
<td style="text-align:left"><strong>束缚：</strong>当公司为防止竞争者进入市场进行自我保护时，对客户、供应商和监管者将加以控制</td>
<td style="text-align:center"><strong>创造力：</strong>当公司努力完善市场时，会创造新的竞争舞台，从而产生创造力</td>
</tr>
<tr>
<td style="text-align:left"><strong>差异化：</strong>对几乎相似的物品所呈现的特征进行表面的（甚至是想象当中的）细分</td>
<td style="text-align:center"><strong>意义：</strong>当公司寻找有意义的回报时将看到差异；当公司真正开始生产对人类有意义的产品时，就已经在创造差异</td>
</tr>
</tbody>
</table>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a><center>笔记</center></h3><ul>
<li>取势、明道、优术</li>
<li>方舟上的经济繁荣取决于最大限度的降低伤害，因为你所攫取的所有利益、转嫁的所有伤害都会造成永久的、可能无法扭转的损失，最终造成一连串无法预知的恶果。</li>
<li>这就是全球经济今天所处的困境。我们现在正在使用狩猎时期的规则来管理这艘方舟，这种经济发展的方法已经过期了。</li>
<li>菲茨帕特里克最重要的一条经验是：在别人挑战你并开始行动之前，突破自己。</li>
<li>每种类型的进步都需要选择。生物学家谈的是自然选择，经济学家谈的是社会选择。经济进步需要竞争性选择，顾客、买方、供货方都必须能自由、公平地在一家公司和他的竞争对手之间做选择。自由、公平的交换是进步的根基，因为这推动了竞争性选择。</li>
<li>这就是我的看法：过去商业社会已经触及了幸福的天花板——从长远来看，其基本理念所能产生的幸福感以及幸福人群的数量都遭遇了瓶颈。最能带来收益的厚价值，也是真正的价值所在——从人性角度出发，对公众、社区、社会有益——反映的是长久的、可见的幸福。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h3 id=&quot;作者简介&quot;&gt;&lt;a href=&quot;#作者简介&quot; class=&quot;headerlink&quot; title=&quot;作者简介&quot;&gt;&lt;/a&gt;&lt;center&gt;作者简介&lt;/center&gt;&lt;/h3&gt;&lt;p&gt;乌麦尔·哈克，全球领先的管理思想家，被Thinkers 50评为全球最具影响力的管理学家之一。在《哈佛商业评论》的博客上发表多篇文章，主要关注领域为经济、领导力、创新等。&lt;/p&gt;
&lt;h3 id=&quot;本书核心&quot;&gt;&lt;a href=&quot;#本书核心&quot; class=&quot;headerlink&quot; title=&quot;本书核心&quot;&gt;&lt;/a&gt;&lt;center&gt;本书核心&lt;/center&gt;&lt;/h3&gt;&lt;p&gt;《新商业文明：从利润到价值》，这本书勾画了一幅未来商业的蓝图，在这样的商业图景下，企业被顾客所爱戴，被竞争者所羡慕，被所有关心我们这个星球未来的人们所尊重。旧商业文明关注利润和股东利益最大化，新商业文明格局下企业更关注与社会、顾客、员工、环境的关系。企业为追求发展，以牺牲环境、社会、大众、后代利益为代价，获得高额利润的同时，却忽略了商业精神的实质。作者本书中提到，商业精神的内涵是企业应该掌握“建设型优势”，即关注真实的价值创造而非仅仅关注股东利益，这要求企业做到几个转变：从价值链到价值循环，从价值主张到价值对话，从战略到哲学，从市场保护到市场完善，从产品到幸福，从盲目增长到智慧增长。基于建设型优势，企业将成为有责任、有担当、有领导力的组织，而一种具备更长远、更开放视角的新商业文明也将形成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Reading Nodes" scheme="http://phoebepan.cn/categories/Reading-Nodes/"/>
    
    
      <category term="Reading" scheme="http://phoebepan.cn/tags/Reading/"/>
    
      <category term="Thinking" scheme="http://phoebepan.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic programming</title>
    <link href="http://phoebepan.cn/2017/04/13/Dynamic%20programming/"/>
    <id>http://phoebepan.cn/2017/04/13/Dynamic programming/</id>
    <published>2017-04-13T07:30:16.000Z</published>
    <updated>2017-05-29T05:01:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>动态规划（Dynamic programming，DP），通过把原问题分解为相对简单的子问题的方式分解复杂问题的方法。</p>
</blockquote>
<a id="more"></a>
<h3 id="使用的情况"><a href="#使用的情况" class="headerlink" title="使用的情况"></a>使用的情况</h3><p>能采用动态规划求解的问题一般具有3个性质：</p>
<ul>
<li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构；</li>
<li>无后效性：某状态以后的过程不会影响以前的状态，只与当前状态有关；</li>
<li>有重叠子问题：子问题之间不独立，一个字问题在下一阶段中可能被多次使用。（这一性质是动态规划与其他算法相比所具备的优势）</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>LeetCode: <a href="https://leetcode.com/problems/wildcard-matching/#/description" target="_blank" rel="external">Wildcard Matching</a><br>这道题其实就是Regular Expression Matching的简化版，下面主要说一下动态规划的解法。<br>输入两个字符串s,p，用一个布尔数组dp，dp[n]值表示字符串s前n个字符是否符合模式p。这就将原问题拆分成很多子问题，要想知道s是否匹配p，只需要知道之前匹配结果及当前位匹配情况就可以ok了。<br>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type p: str</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        length = len(s)</div><div class="line">        <span class="keyword">if</span> len(p)-p.count(<span class="string">'*'</span>) &gt; length:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        dp = [<span class="keyword">True</span>]+[<span class="keyword">False</span>]*length</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> p:</div><div class="line">            <span class="keyword">if</span> i != <span class="string">'*'</span>:</div><div class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> reversed(range(length)):</div><div class="line">                    dp[n+<span class="number">1</span>]=dp[n] <span class="keyword">and</span> (i==s[n] <span class="keyword">or</span> i == <span class="string">'?'</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,length+<span class="number">1</span>):</div><div class="line">                    dp[n]=dp[n<span class="number">-1</span>] <span class="keyword">or</span> dp[n]</div><div class="line">            dp[<span class="number">0</span>]=dp[<span class="number">0</span>] <span class="keyword">and</span> i==<span class="string">'*'</span></div><div class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</div><div class="line"><span class="comment">#test</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isMatch(<span class="string">'aa'</span>,<span class="string">'*'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isMatch(<span class="string">"ab"</span>, <span class="string">"?*"</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>)</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h3 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h3&gt;&lt;p&gt;动态规划（Dynamic programming，DP），通过把原问题分解为相对简单的子问题的方式分解复杂问题的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://phoebepan.cn/categories/Algorithms/"/>
    
    
      <category term="LeetCode" scheme="http://phoebepan.cn/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://phoebepan.cn/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>读《好好学习》</title>
    <link href="http://phoebepan.cn/2017/04/09/goodstudy/"/>
    <id>http://phoebepan.cn/2017/04/09/goodstudy/</id>
    <published>2017-04-09T07:30:16.000Z</published>
    <updated>2017-05-29T05:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>简介：被罗辑思维评为十位“全国最会学习的人之一”，“得到”最受欢迎的说书人成甲，为你解开学习迷思，讲授“学习的方法”，帮助你将零碎的知识体系打造为高效的知识管理体系，让所学知识真正变成你的资产，让学习成为你财富积累的过程！</p>
</blockquote>
<a id="more"></a>
<p>知识和知识是不一样的，有些知识比其他知识的威力更大。少数的知识能够给我们带来关键的影响，这就是临界知识。</p>
<blockquote>
<p><strong>我</strong>    这是作者给出的临界知识的定义，通读全书，我觉得所谓临界知识，更接近一般的底层规律，从小学到大学，我们不断地在学习知识，信息爆炸的互联网时代，知识的数量更大，知识的获取更便捷，而人的时间精力是有限的，如何将知识内化，提升认知效率，加强个人知识深度那真可谓是“磨刀石”，就自身而言，maybe我也入了“低水平勤奋陷阱”，看似不断学习，但大多数只是停留在知道层面，没有内化为自己的能力，二八原理有说，20%的知识比80%的知识要有用，这20%的关键知识就是撬动效能的杠杆点，我们要做的是花80%的时间，用在这20%的关键问题上，而不是平均地把时间花在各种知识上。</p>
</blockquote>
<p>我们所谓的专业，比如市场营销、法律、政治、历史、文学，其实只是人为制造的分类标签罢了，但是，这个世界不是按照你划分的标签在各个专业之内单独运行的。一个市场营销的问题，背后往往涉及法律、政治、历史和文化的因素。可是我们所谓的专业，并不管这些：你学好4P（产品、价格、渠道、促销）、市场细分等概念，就可以毕业了。这种认识，会极大地阻碍我们学习真正应该学的知识。</p>
<blockquote>
<p><strong>我</strong>    对于专业的解说，很符合自己的反思过程，以前自己读书总是读文学名著，专业书籍，至于其他领域，基本不会深入阅读，也许可归因于曾经浮躁的状态，想了解更多，但又觉得无用，受制于自己给贴的标签。但渐渐的我发现，很多时候，知识是相通的，想要在某一方面做到极致，不是说只学习某个专业知识就够了，也不是简单地这也学学，那也学学，而是要学习与解决某一类问题相关的所有核心能力。这一点，一定是突破专业限制的。</p>
</blockquote>
<p>生命有限，不要把有限的生命浪费在那些“低水平勤奋陷阱”里。现在的我，在读书时既不追求数量，也不要求读完。我的做法是：当我要解决某个问题的时候，主动去寻找可能会讨论这个问题的文章和书籍，去观察——作者用什么样的思路解决这个问题？在解决方案背后，是否有我熟悉的知识？我还能把这个解决方案的原理应用在什么领域？</p>
<blockquote>
<p><strong>我</strong>    这点挺启发我的，我拿起一本书要看的时候，总是，从前言，目录一直到结尾，生怕落下什么重要的细节，而且我总想尽快读完，然后去读更多的书，但maybe这真的是低效的表现，读书不在于多少，而在于有没有通过读书重新认识这个世界，发现深度知识并把它运用到自己的生活当中，举一反三，学习这样的检视阅读，把书当做自己的一个私人顾问，让自己以后能更高效解决问题。</p>
</blockquote>
<p>区分“我”和“我的观点/行为”，不再把对自己观点的质疑与自己这个人绑定起来。乔布斯在生前说过一句很著名的话：“我特别喜欢和聪明人在一起工作，因为最大的好处是不用考虑他们的尊严”</p>
<blockquote>
<p><strong>我</strong>    深有感触，以前实习的时候，两个老师之间意见不一致，其中一个的威信明显受到挑衅，当时就很困惑，难道老师不担心自己丢面子？不害怕没有尊严？其实不是，聪明人他们知道尊严不是在别人驳倒自己时去维护面子，真正的尊严是发现改进和成长的机会，成为更好的自己，这才是真正的老司机啊，哈哈。</p>
</blockquote>
<p>学习临界知识其实也就是用更合理的假设来替代我们过去不合理的假设，从而让我们的决策质量更高。<br>做事的顺序：做出假设——&gt;采取行动——&gt;产生结果<br>反思的顺序：观察结果（现象）——&gt;研究原先假设——&gt;反思校正假设</p>
<blockquote>
<p><strong>我</strong>    学习的本质，就是改变我们假设的过程，这讲清楚了学习的目的，因为，我们做出的所有决策都是在自己的假设下做出的，如果自己的假设不正确，不合适，那么必然产生不好的结果，所以学习，能够帮助我们更好的应对这个变化的世界。</p>
</blockquote>
<p>而我个人也是从事广告的6年间每天保持着阅读10个以上广告案例的习惯。正是这些背后看不见的可以练习，才铸就了今天小马宋举重若轻的广告能力。</p>
<blockquote>
<p><strong>我</strong>    真的没有谁，是随随便便成功的，台上十分钟，台下十年功，保持足够的好奇，寻找自己的热情所在，戒骄戒躁，在如今尤为重要，想想自己浪费的一年多生活，有些惋惜，但浪子回头，什么时候都不会晚，我坚信可以变成更好的自己。</p>
</blockquote>
<p>复利的本质？做事情A会导致结果B，而结果B又会加强A，不断循环。生活中，凡是符合这一规律的事情，都可以视为复利效应。比如，网站的访问量越多，在搜索引擎的排名就越靠前，那么网站访问量就越多。</p>
<blockquote>
<p><strong>我</strong>    复利，这个概念来源自我们小学就接触到的利息模型。近年来，读书无用论盛行，家长们会说，孩子学习这些数学有什么用，生活中也用不到，你看，这个复利，我们简单的停留在求出利息的层面，那它的用途的确有限，但是如果把它抽象出来，结合二八原理，书中提到我们想要向前20%靠近的话，就要充分利用复利效应，而这就需要我们做到：首先，我们要在生活中发现“A导致B，B加强A”这样的事情；其次，我们要尽可能地提高这件事情的利率；最后，我们要加强这件事情重复发生的可能性。</p>
</blockquote>
<p>所以拓展人脉的关键，首先是不断地提升自己的价值，让自己变得对他人有帮助；其次，才是让别人知道自己的价值。</p>
<blockquote>
<p><strong>我</strong>    来沪也快两年了，参加过一些活动，认识了一些朋友，虽然有些只是一面之交，但真的特别感谢每次的相遇，让我的眼界更加开阔。印象比较深的是，有一次参加一个英语角活动，活动后我们几个年龄相仿的，聊得特别嗨，一眨眼二三个小时过去了，但仍然意犹未尽，互加了微信，回去过后，有一个程序员哥哥，每次看到可能对我有帮助的，都会分享给我，我这个人么，属于能不麻烦别人就不麻烦别人的，但渐渐我发现，朋友其实就是在这样互相帮助下，联系的越紧密的，现在的我特别喜欢，有事就联系，没事各忙各的这样的相处方式。</p>
</blockquote>
<p>我不是说老司机的经验没有价值。我是说，你要意识到老司机的经验，只是众多可能性中的一个可能性，千万不能把它当成真理。它只是这个世界各种概率下的一个，甚至可能是小概率下的那一个。</p>
<blockquote>
<p><strong>我</strong>    这里讲的就是概率模型，这也是为什么我讨厌别人给我灌鸡汤，跟我讲大道理的原因，我始终都认为，一个人的成功，天时地利人和，缺一不可，老司机的经验，并不能保证在你所处的场景下也发生，只能规避你的风险，这也是我看好罗胖的内容创业，但是不会成为得到的深度用户。</p>
</blockquote>
<p>“与鬼共舞”其大意是说一个物种在适应过去的环境时，会形成一种行为A；当环境发生变化不需要行为A了，可物种仍然会延续过去的做法，就像与鬼魂共舞一样。</p>
<blockquote>
<p><strong>我</strong>    书里面提到的例子说，父母让女儿远离一线城市高房价，高压力的生活，回到自己的家乡县城，做稳定的银行柜员。我一直都坚信，没有所谓的稳定，环境在不断的变化，但是如果我们行动跟不上这样的变化，就会在新环境中“与鬼共舞”。我呢，天生爱自由，喜欢变化的世界，厌倦一层不变，这也是我渴望进入互联网这个行业的原因。</p>
</blockquote>
<p>夫夷以近，则游者众；险以远，则至者少。让我们一起好好学习，成为更好的自己~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;简介：被罗辑思维评为十位“全国最会学习的人之一”，“得到”最受欢迎的说书人成甲，为你解开学习迷思，讲授“学习的方法”，帮助你将零碎的知识体系打造为高效的知识管理体系，让所学知识真正变成你的资产，让学习成为你财富积累的过程！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://phoebepan.cn/categories/Thinking/"/>
    
    
      <category term="Reading" scheme="http://phoebepan.cn/tags/Reading/"/>
    
      <category term="Thinking" scheme="http://phoebepan.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>魔力Python—— 查找列表项与np.genefromtxt()</title>
    <link href="http://phoebepan.cn/2017/03/25/python_genefromtxt/"/>
    <id>http://phoebepan.cn/2017/03/25/python_genefromtxt/</id>
    <published>2017-03-25T07:30:16.000Z</published>
    <updated>2017-05-29T05:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a><center>Part1</center></h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>python，想获取列表中满足某一要求的所有列表项的索引。如这样的列表：<font color="red">a = [‘id:123’,’is_a:ja’,’name:ad’,’is_a: dj’]</font>，需得到含有<font color="red">‘is_a’</font>的两个列表项索引。<br><a id="more"></a></p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="startswith"><a href="#startswith" class="headerlink" title="startswith()"></a>startswith()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [<span class="string">'id:123'</span>,<span class="string">'is_a:ja'</span>,<span class="string">'name:ad'</span>,<span class="string">'is_a: dj'</span>]</div><div class="line">[ i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(a) <span class="keyword">if</span> word.startswith(<span class="string">'is_a:'</span>) ]</div><div class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<h4 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [<span class="string">'id:123'</span>,<span class="string">'is_a:ja'</span>,<span class="string">'name:ad'</span>,<span class="string">'is_a: dj'</span>]</div><div class="line">[ i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(a) <span class="keyword">if</span> re.search(<span class="string">'is_a:'</span>,word) ]</div><div class="line">&gt;&gt;&gt;[<span class="number">1</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a><center>Part2</center></h2><h3 id="Background-1"><a href="#Background-1" class="headerlink" title="Background"></a>Background</h3><p>在读取数据文本时，遇到这样的问题，结构文本数据值默认为空，或者是缺失的，这时加载时，就需要对其进行处理，设定一个默认值。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h4 id="numpy-genefromtxt"><a href="#numpy-genefromtxt" class="headerlink" title="numpy.genefromtxt()"></a><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html" target="_blank" rel="external">numpy.genefromtxt()</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">将test.csv里的空值用'0'来代替，test.txt内容如下：</div><div class="line">1,,1,</div><div class="line">,,1,</div><div class="line">,,,</div><div class="line">,1,,</div><div class="line"></div><div class="line">'''</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">data = np.genfromtxt(<span class="string">'test.csv'</span>, delimiter=<span class="string">','</span>, missing_values=[<span class="string">''</span>],filling_values=<span class="string">'0'</span>)</div><div class="line">&gt;&gt;&gt;data</div><div class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</div><div class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</div><div class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</div><div class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</div></pre></td></tr></table></figure>
<center><strong>Keep calm and carry on</strong></center>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Part1&quot;&gt;&lt;a href=&quot;#Part1&quot; class=&quot;headerlink&quot; title=&quot;Part1&quot;&gt;&lt;/a&gt;&lt;center&gt;Part1&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h3&gt;&lt;p&gt;python，想获取列表中满足某一要求的所有列表项的索引。如这样的列表：&lt;font color=red&gt;a = [‘id:123’,’is_a:ja’,’name:ad’,’is_a: dj’]&lt;/font&gt;，需得到含有&lt;font color = red&gt;‘is_a’&lt;/font&gt;的两个列表项索引。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>魔力Python——fileinput &amp; bisect模块</title>
    <link href="http://phoebepan.cn/2017/03/23/fileinput_bisect_/"/>
    <id>http://phoebepan.cn/2017/03/23/fileinput_bisect_/</id>
    <published>2017-03-23T07:30:16.000Z</published>
    <updated>2017-05-29T05:03:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h3 id="fileinput"><a href="#fileinput" class="headerlink" title="fileinput"></a>fileinput</h3><p>　　<strong>起因：</strong>小伙伴Q我问，如何用python在一个txt每行末尾添加内容？</p>
</blockquote>
<a id="more"></a>
<p>　　我想了下，这不简单么，直接for循环读取每行再在末尾加新内容，然后重新写入新文档不就解决了么。想着这肯定不是小伙伴希望的，能不能直接在原文档添加，不写入新文档呢？</p>
<p>　　这就了解到了fileinput模块，那么它能帮我干什么嘞！如：有一个test.txt，里面的内容如下：<br>|1|a|<br>|2|b|<br>|3|c|<br>　　那么，执行下面的代码，就能在test.txt文档每行末尾添加<font color="red">‘aaa’</font>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> fileinput</div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input(<span class="string">'test.txt'</span>, inplace=<span class="number">1</span>):</div><div class="line">    print(<span class="string">'&#123;0&#125;\t&#123;1&#125;'</span>.format(line.rstrip(<span class="string">'\n'</span>), <span class="string">'aaa'</span>))</div></pre></td></tr></table></figure></p>
<h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><p>　　这是Lab小伙伴推荐的python排序模块，点<a href="http://www.cnblogs.com/skydesign/archive/2011/09/02/2163592.html" target="_blank" rel="external">这</a>学习模块具体内容。</p>
<p>　　在LeetCode刷到<a href="https://leetcode.com/problems/reverse-pairs/#/description" target="_blank" rel="external">Reverse Pairs</a>这题时，我灵机一动，想到了用这个小模块非常简洁的写出了代码，虽然时间复杂度比用归并排序高，但不失为一种方法。</p>
<p>　　题目大意：给定数组nums，定义所有满足i &lt; j 并且nums[i] &gt; 2 * nums[j]的数对(i, j)为“重要的逆序对”（important reverse pair），返回其个数。</p>
<p>　　下面是我用bisect写的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> bisect</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">( self,nums)</span>:</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        done = []</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">            count += len(done) - bisect.bisect(done, num * <span class="number">2</span>)</div><div class="line">            bisect.insort(done, num)</div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure></p>
<p>　　归并排序的解参见我的<a href="https://github.com/phoebepx/Algorithm/blob/master/LeetCode/Reverse%20Pairs.py" target="_blank" rel="external">github</a>。</p>
<center><strong>Talk is cheap. Show me the code.</strong></center>




]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h3 id=&quot;fileinput&quot;&gt;&lt;a href=&quot;#fileinput&quot; class=&quot;headerlink&quot; title=&quot;fileinput&quot;&gt;&lt;/a&gt;fileinput&lt;/h3&gt;&lt;p&gt;　　&lt;strong&gt;起因：&lt;/strong&gt;小伙伴Q我问，如何用python在一个txt每行末尾添加内容？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Binary indexed tree (Fenwick tree)</title>
    <link href="http://phoebepan.cn/2017/03/21/binary_indexed_tree/"/>
    <id>http://phoebepan.cn/2017/03/21/binary_indexed_tree/</id>
    <published>2017-03-21T07:30:16.000Z</published>
    <updated>2017-05-29T04:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文主要介绍<font color="red">Binary indexed tree (Fenwick tree)</font>，也叫<strong>树状数组</strong>。<br><a id="more"></a></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h3><ul>
<li>数组中每一个元素都是原数组中一个或多个连续元素之和；</li>
<li>连续求和a[0]+a[1]+…+a[n]时，只需要树状数组几个元素之和，时间复杂度为O(logn)；</li>
<li>更改原数组某一元素值，只需要更改几个树状数组元素，时间复杂度为O(logn)。</li>
</ul>
<p>　　下图，是树状数组的示意图：<br><img src="/images/binary_indexed_tree.jpg" width="150%" height="70%" align="center/"></p>
<h4 id="lowbit-x-函数"><a href="#lowbit-x-函数" class="headerlink" title="lowbit(x)函数"></a><strong>lowbit(x)函数</strong></h4><p>　　定义lowbit(x)为x的二进制形式最右边1所对应的值。<br>　　如，6的二进制是110 lowbit(6)=2。</p>
<h4 id="前继"><a href="#前继" class="headerlink" title="前继"></a><strong>前继</strong></h4><p>　　上图中，e[3]的前继是e[2]，e[6]的前继是e[4]，即结点e[i]的前继为e[i-lowbit(i)]。</p>
<h4 id="后继"><a href="#后继" class="headerlink" title="后继"></a><strong>后继</strong></h4><p>　　e[2]的后继是e[4]，e[6]的后继是e[8]，即结点e[i]的后继为e[i+lowbit(i)]。</p>
<p>　　由示意图可看出，e[i]是原数组第i-lowbit(i)+1到第i项的和，计算原数组sum[6]=e[6]+e[4]，更改a[1]，只需要更新e[1],e[2],e[4]……直到最大值。</p>
<p>　　Python实现树状数组代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.n = n</div><div class="line">        self.sums = [<span class="number">0</span>] * (n + <span class="number">1</span>)</div><div class="line">    <span class="comment">#更新元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x, val)</span>:</span></div><div class="line">        <span class="keyword">while</span> x &lt;= self.n:</div><div class="line">            self.sums[x] += val</div><div class="line">            x += self.lowbit(x)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowbit</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="keyword">return</span> x &amp; -x   <span class="comment">#计算机内部-x是将x按位取反，再加1</span></div><div class="line">    <span class="comment">#计算原数组a[0]+a[1]+…+a[x]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, x)</span>:</span></div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</div><div class="line">            res += self.sums[x]</div><div class="line">            x -= self.lowbit(x)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><p>　　求一个整数数组nums的逆序对数时，可以运用树状数组实现，时间复杂度降到O(nlogn)。</p>
<p>思路：</p>
<ol>
<li>首先对nums去重，确定每一个元素具体排位；</li>
<li>从右向左，统计小于每个排位的元素个数，并将这一排位加入到树状数组。</li>
</ol>
<p>　　具体实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    :type nums: List[int]</div><div class="line">    :rtype: List[int]</div><div class="line">    """</div><div class="line">    <span class="comment">#去重+排序</span></div><div class="line">    insort=&#123;&#125;</div><div class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(sorted(set(nums))):</div><div class="line">        insort[v]=k+<span class="number">1</span></div><div class="line">    snums = [insort[x] <span class="keyword">for</span> x <span class="keyword">in</span> nums]</div><div class="line">    result = [<span class="number">0</span>]*len(nums)</div><div class="line">    ft = FenwickTree(len(nums))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(snums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">        result[i]=ft.sum(snums[i]<span class="number">-1</span>)    <span class="comment">#求出第snums[i]排位的逆序数</span></div><div class="line">        ft.add(snums[i],<span class="number">1</span>)              <span class="comment">#将其加入树状数组</span></div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文主要介绍&lt;font color=red&gt;Binary indexed tree (Fenwick tree)&lt;/font&gt;，也叫&lt;strong&gt;树状数组&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://phoebepan.cn/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://phoebepan.cn/tags/Algorithms/"/>
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>魔力Python——collections</title>
    <link href="http://phoebepan.cn/2017/03/21/python_collections/"/>
    <id>http://phoebepan.cn/2017/03/21/python_collections/</id>
    <published>2017-03-21T07:30:16.000Z</published>
    <updated>2017-05-29T05:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="collections是Python内建的一个集合模块，提供了许多有用的集合类。"><a href="#collections是Python内建的一个集合模块，提供了许多有用的集合类。" class="headerlink" title="collections是Python内建的一个集合模块，提供了许多有用的集合类。"></a><font color="red"><strong>collections</strong></font>是Python内建的一个集合模块，提供了许多有用的集合类。</h3><a id="more"></a>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a><strong>namedtuple</strong></h3><p>tuple可表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<blockquote>
<p>A = (2,3)</p>
</blockquote>
<p>但是，看到(2,3)这样的tuple很难联想到一个点坐标，定义一个class，又很鸡肋，大材小用，此时，<font color="red">namedtuple</font>就派上用场了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line">Point = namedtuple(<span class="string">'Point'</span>,(<span class="string">'x'</span>,<span class="string">'y'</span>))</div><div class="line">A = Point(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">print(A.x,A.y)   </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="number">3</span></div></pre></td></tr></table></figure></p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a><strong>deque</strong></h3><p>由于<font color="red">list</font>是线性存储，按索引访问元素很快，但数据量大时，插入和删除效率较低。deque是为实现高效插入和删除的双向列表，适用于栈和队列。</p>
<p><font color="red">deque</font>除了list的<font color="red">append()</font>和<font color="red">pop()</font>，还支持<font color="red">appenleft()</font>和<font color="red">popleft()</font>，这就可以高效的往头部插入或删除元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#用deque查找图中start-&gt;goal两结点的路径</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_paths</span><span class="params">(graph, start, goal)</span>:</span></div><div class="line">    queue = deque([(start,[start])])</div><div class="line">    <span class="keyword">while</span> queue:</div><div class="line">        vertex,path= queue.popleft()</div><div class="line">        <span class="keyword">if</span> vertex==goal:</div><div class="line">            <span class="keyword">yield</span> path</div><div class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> graph[vertex]-set(path):</div><div class="line">            queue.extend([(next,path+[next])])</div></pre></td></tr></table></figure></p>
<h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a><strong>defaultdict</strong></h3><p>使用<font color="red">dict</font>时，常常会遇到引用的key不存在，而报错，如果希望可以不存在时，返回一个默认值，可以用<font color="red">defaultdict</font>：<br><strong>用法1：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">d = defaultdict(<span class="keyword">lambda</span>: <span class="string">'Error'</span>)</div><div class="line">d[<span class="string">'1'</span>] = <span class="string">'a'</span></div><div class="line">print(d[<span class="string">'1'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a       <span class="comment">#key存在</span></div><div class="line">print(d[<span class="string">'2'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Error   <span class="comment">#key不存在</span></div></pre></td></tr></table></figure></p>
<p><strong>用法2：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collections</div><div class="line">s = <span class="string">'mississippi'</span></div><div class="line">d = defaultdict(int)	<span class="comment">#该语句创建一个defaultdict类型，value类型是指定的int类型</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> s:</div><div class="line">    d[k] += <span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(d.items())</div><div class="line">[(<span class="string">'i'</span>, <span class="number">4</span>), (<span class="string">'p'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">4</span>), (<span class="string">'m'</span>, <span class="number">1</span>)]</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collections</div><div class="line">s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</div><div class="line">d = collections.defaultdict(list)	<span class="comment">#该语句创建一个defaultdict类型，value类型是指定的list类型</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</div><div class="line">    d[k].append(v)</div><div class="line">&gt;&gt;&gt;list(d.items())</div><div class="line">[(<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</div></pre></td></tr></table></figure>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a><strong>Counter</strong></h3><p><font color="red">Counter</font>是一个简单的计数器，可统计字符出现的个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line">A = Counter()</div><div class="line">str1=<span class="string">'hello word'</span></div><div class="line"><span class="keyword">for</span> s <span class="keyword">in</span> str1:</div><div class="line">    A[s]+=<span class="number">1</span></div><div class="line">print(A)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">'l'</span>: <span class="number">2</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a><strong>OrderedDict</strong></h3><p>使用<font color="red">dict</font>时，key是无序的，若要使key保持有序，可使用<font color="red">OrderedDict</font>，它可以实现一个先进先出(FIFO)的dict，当超出容量，删除最先进入的key。<br>实例：<br>LeetCode——<a href="https://leetcode.com/problems/lru-cache/#/description" target="_blank" rel="external">LRU Cache</a><br>题目大意，就是实现一个近期最少使用(LRU)缓存的数据结构，支持put和get操作。<br>get(key)-取值(key恒为正)，不存在返回-1；<br>put(key,value)-插入或替换(缓存容量达到上限，移除近期最少使用的元素)。</p>
<p>运用OrderedDict解题代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type capacity: int</div><div class="line">        """</div><div class="line">        self.capacity=capacity</div><div class="line">        self.cache = OrderedDict()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type key: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> key <span class="keyword">in</span> self.cache.keys():</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment">#一定要弹出再重新插入，不然体现不了最近最少使用</span></div><div class="line">            value = self.cache.pop(key)</div><div class="line">            self.cache[key] = value</div><div class="line">            <span class="keyword">return</span> value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type key: int</div><div class="line">        :type value: int</div><div class="line">        :rtype: void</div><div class="line">        """</div><div class="line">        <span class="comment">#2种特殊情况，key在缓存中，弹出再插；容量达到上限，弹出最近最少使用的</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache.keys():</div><div class="line">            self.cache.pop(key)</div><div class="line">        <span class="keyword">elif</span> self.capacity==len(self.cache):</div><div class="line">            self.cache.popitem(last = <span class="keyword">False</span>)</div><div class="line">        self.cache[key]=value</div></pre></td></tr></table></figure></p>
<p>此题，虽然用OrderedDict可以很简洁的解决，但是不够高效，更快速的方法，可采用双链表实现，双链表实现细节参见我的<a href="https://github.com/phoebepx/Algorithm/blob/master/LeetCode/LRU%20Cache.py" target="_blank" rel="external">Github</a>(method2)。</p>
<center><strong>Talk is cheap. Show me the code.</strong></center>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;collections是Python内建的一个集合模块，提供了许多有用的集合类。&quot;&gt;&lt;a href=&quot;#collections是Python内建的一个集合模块，提供了许多有用的集合类。&quot; class=&quot;headerlink&quot; title=&quot;collections是Python内建的一个集合模块，提供了许多有用的集合类。&quot;&gt;&lt;/a&gt;&lt;font color=red&gt;&lt;strong&gt;collections&lt;/strong&gt;&lt;/font&gt;是Python内建的一个集合模块，提供了许多有用的集合类。&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>朗读者「百合花开」</title>
    <link href="http://phoebepan.cn/2017/03/20/reader/"/>
    <id>http://phoebepan.cn/2017/03/20/reader/</id>
    <published>2017-03-20T07:30:16.000Z</published>
    <updated>2017-05-29T05:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1"><a href="#1" class="headerlink" title="1"></a><center>1</center></h4><p>　　总有一段文字，那时那刻有着非常特别的意义，早上在跑步机上听到蒋雯丽朗读的百合花开，一方面被她流露出的情感打动，另一方面超级喜爱这段文字，百合我爱，但更爱它这股傲劲。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a><center>2</center></h4><p>　　最近迷上了算法，特别当自己没想到，而别人超级concise的方法，这种醍醐灌顶的感觉，真的蛮爽的！<br><a id="more"></a></p>
<h4 id="附：原文"><a href="#附：原文" class="headerlink" title="附：原文"></a>附：原文</h4><p>　　在一个偏僻遥远的山谷里，有一处数千尺高的断崖。不知道什么时候，断崖边上长出了一株小小的百合。</p>
<p>　　起初，百合长得和野草一模一样。但是，它心里知道自己不是一株野草。它的内心深处有这样一个念头：“我是一株百合，不是野草。唯一能证明我是百合的方法，就是开出美丽的花朵。”</p>
<p>　　有了这个念头，百合努力地吸收水分和阳光，深深地扎根，直直地挺着胸膛。</p>
<p>　　终于，在一个春天的清晨，百合的顶部结出了第一个花苞。</p>
<p>　　百合的心里很高兴，附近的野草却很不屑，它们在私底下嘲笑百合：“这家伙明明是一株草，却偏偏说自己是一株花，我看它顶上结的根本不是花苞，而是长了一个疙瘩……”</p>
<p>　　在公开场合，它们也嘲笑百合：“你不要做梦了！即使你真的会开花，在这荒郊野外，你的价值还不是跟我们一样。”</p>
<p>　　偶尔有飞过的蜂蝶鸟雀，它们也会劝百合不用那么努力地开花：“在这断崖边上，纵然开出世界上最美的花，也不会有人来欣赏啊！”</p>
<p>　　百合说：“我要开花，是因为我知道自己有美丽的花；我要开花，是为了完成作为一株花的庄严生命；我要开花，是由于自己喜欢以花来证明自己的存在。不管有没有人欣赏，不管你们怎么看我，我都要开花！”</p>
<p>　　在野草和蜂蝶的鄙夷嘲笑下，百合努力地生长着。终于有一天，它开花了。</p>
<p>　　百合花一朵一朵地盛开着，花朵上每天都有晶莹的水珠，野草们以为那是昨夜的露水；只有百合自己知道，那是极深沉的欢喜所结出的泪滴。它那透着灵性的洁白和秀挺的风姿，成了断崖上最美丽的一道景色。</p>
<p>　　这时候，野草和蜂蝶再也不嘲笑它了。</p>
<p>　　此后，年年春天，百合都努力地开花，结籽。它的种子随着风落在山谷、草地和悬崖边上，让那些地方到处都开满洁白的百合。</p>
<p>　　几十年后，人们从城市，从乡村，千里迢迢赶来欣赏百合开花。孩子们跪下来，快乐地嗅着百合花的芬芳；情侣们手拉着手，许下“百年好合”的誓言……无数的人看到这从未见过的美丽，感动得直落泪。</p>
<p>　　那里，被人称为“百合谷”。</p>
<p>　　不管别人怎么欣赏，满山的百合花都谨记着第一株百合的教导：“我们要全心全意默默地开花，用花来证明自己的存在。”</p>
<center><strong>默默开花，用花来证明自己的存在！</strong></center>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;&lt;center&gt;1&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;　　总有一段文字，那时那刻有着非常特别的意义，早上在跑步机上听到蒋雯丽朗读的百合花开，一方面被她流露出的情感打动，另一方面超级喜爱这段文字，百合我爱，但更爱它这股傲劲。&lt;/p&gt;
&lt;h4 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2&quot;&gt;&lt;/a&gt;&lt;center&gt;2&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;　　最近迷上了算法，特别当自己没想到，而别人超级concise的方法，这种醍醐灌顶的感觉，真的蛮爽的！&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://phoebepan.cn/categories/Thinking/"/>
    
    
      <category term="Thinking" scheme="http://phoebepan.cn/tags/Thinking/"/>
    
      <category term="Life" scheme="http://phoebepan.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>魔力Python——yield &amp; yield from</title>
    <link href="http://phoebepan.cn/2017/03/17/python_yield/"/>
    <id>http://phoebepan.cn/2017/03/17/python_yield/</id>
    <published>2017-03-17T07:30:16.000Z</published>
    <updated>2017-05-29T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>起因：</strong>在图论中，实现广度搜索两顶点所有路径时，被好用的 yield 和 yield from 惊呆啦~<br><a id="more"></a><br><em>题外话：</em> 想真正搞明白这两者，先学习两个名词，<strong>迭代器</strong> 、<strong>生成器</strong>。</p>
<p>　　先说迭代器，对于<font color="red">string、list、dict、tuple</font>等容器对象，用<font color="red">for</font>循环遍历是很方便的，在后台<font color="red">for</font>语句对容器对象调用<font color="red">iter()</font>函数，<font color="red">iter()</font>会返回一个定义了<font color="red">next()</font>方法的迭代器对象，从而在容器中逐个访问容器内元素，直到最后抛出<font color="red">StopIteration</font>异常，for循环结束。</p>
<p>　　生成器是创建迭代器的简单而强大的工具，能做到迭代器能做的所有事，自动创建<font color="red">iter()和next()</font>方法，自动抛出<font color="red">StopIteration</font>异常。一个带<font color="red">yield</font>的函数就是一个生成器。</p>
<p>　　好，了解了迭代器与生成器，看看yield的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        <span class="keyword">yield</span> i</div></pre></td></tr></table></figure></p>
<p>　　上面的<font color="red">generator()</font>函数就是一个带<font color="red">yield</font>的生成器，执行<font color="red">print(list(generator()))</font>，就会输出[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]这样的列表。</p>
<p>　　Python3.3版本的PEP 380中添加了yield from语法，允许一个生成器将其部分操作委派给另一个生成器。其产生的动力在于使生成器能够容易分为多个拥有send和throw方法的子生成器。进一步了解可参考Stack Overflow上的经典解释<a href="http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3" target="_blank" rel="external">yield from主要有什么用?</a></p>
<p>　　知道了，yield 和 yield from，下面这段代码是我结合这两者，求图中两个顶点之间广度搜索路径：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#def a undirected graph</span></div><div class="line">graph = &#123;<span class="string">'A'</span>: set([<span class="string">'B'</span>, <span class="string">'C'</span>]),</div><div class="line">         <span class="string">'B'</span>: set([<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]),</div><div class="line">         <span class="string">'C'</span>: set([<span class="string">'A'</span>, <span class="string">'F'</span>]),</div><div class="line">         <span class="string">'D'</span>: set([<span class="string">'B'</span>]),</div><div class="line">         <span class="string">'E'</span>: set([<span class="string">'B'</span>, <span class="string">'F'</span>]),</div><div class="line">         <span class="string">'F'</span>: set([<span class="string">'C'</span>, <span class="string">'E'</span>])&#125;</div><div class="line"></div><div class="line"><span class="comment">#dfs </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_paths</span><span class="params">(graph,start,goal,path=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> path <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        path = [start]</div><div class="line">    <span class="keyword">if</span> start == goal:</div><div class="line">        <span class="keyword">yield</span> path</div><div class="line">    <span class="keyword">for</span> next <span class="keyword">in</span> graph[start] - set(path):</div><div class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> dfs_paths_recursion(graph, next, goal, path + [next])</div><div class="line"></div><div class="line"><span class="comment"># test</span></div><div class="line">print(list(dfs_paths(graph,<span class="string">'A'</span>,<span class="string">'F'</span>,path=<span class="keyword">None</span>)))</div><div class="line">[[<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>], [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]]</div></pre></td></tr></table></figure></p>
<p>　　总之，这是一个魔法语句，简洁明了，nice，i love Python！</p>
<center><strong>Talk is cheap. Show me the code.</strong></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;起因：&lt;/strong&gt;在图论中，实现广度搜索两顶点所有路径时，被好用的 yield 和 yield from 惊呆啦~&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://phoebepan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://phoebepan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>读《块数据》</title>
    <link href="http://phoebepan.cn/2017/03/15/read_block_data/"/>
    <id>http://phoebepan.cn/2017/03/15/read_block_data/</id>
    <published>2017-03-15T07:30:16.000Z</published>
    <updated>2017-05-29T05:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作者简介：</strong>本书是大数据战略重点实验室编写，是实验室集中一批大数据领域专家学者、实践者和郑策制定者的力量，在调研大量大数据企业、相关政府职能部门、各类社会组织后集中撰写的。<br><a id="more"></a><br>　　我呢，是在周末逛校图书馆的时候，被“块数据”三个字和书的封面吸引，而读了这本书，给了我对数据产业链的新认识，开卷有益，下面是自己的读书笔记与小思考。</p>
<p>　　呃，问题来了，标题党肯定要问了，块数据是神(Ni)马(Kuai)东(Shuo)东(Shuo)?</p>
<blockquote>
<p><strong>我：</strong>要了解块数据，首先得知道什么是条数据，条数据是一个领域或行业内纵深数据的集合，可反映该领域或行业的规律。相对的，块数据就是一个物理区域或行政区块内众多条数据的集合。</p>
</blockquote>
<p>块数据提出的缘由？</p>
<blockquote>
<p><strong>我：</strong>书中提到这个时代是大数据和小数据并驾齐驱的时代，是数据的融合成为数据价值提升关键的时代，条数据成长面临的烦恼：数据孤岛，数据资产垄断（单维度性和封闭性，被少数企业垄断，不开放不流通），数据预测失真（以偏概全）。于似乎坐拥天时地利的宠儿块数据诞生啦。</p>
</blockquote>
<p>条块数据的关系？</p>
<blockquote>
<p><strong>我：</strong>打个比方，块数据就像一个计算机的主板，它建立起了一个开放、共享连接的数据基地，而各个行业和部门的条数据就像一个个可插可拔的板卡，它们只有融合和集成到主板上，才能发挥数据资产真正的价值。</p>
</blockquote>
<p>块数据孕育出哪些商业模式呢？</p>
<ul>
<li>数据产业：围绕数据的采集、处理、分析和应用所形成的的商业模式；</li>
<li>数据革命：颠覆或再造传统商业模式（应用服务、咨询服务）；</li>
<li>数据资产：围绕数据交易所形成的商业模式（数据现货、期货交易等）；</li>
</ul>
<p>块数据处理流程？</p>
<ul>
<li><em>采集与传输</em>：<strong>采集</strong>，POS、GPS、智能终端、监控设备、RFID设备、传感设备等；<strong>传输</strong>，有线与无线传输、光传输等。 </li>
<li><em>存储与管理</em>：分布式DB、NoSQL、DAS、NAS、SAN、磁芯库；分布式文件系统(Hadoop)、分布式计算系统(MapReduce)等。</li>
<li><em>挖掘与分析</em>：数据挖掘、深度学习等；数据分析：专家系统、大数据一体机、关联分析、逻辑分析等。</li>
<li><em>解读与可视化</em>：可视化计算、立体可视化、信息可视化等；</li>
</ul>
<p>把数据变成一门生意？</p>
<blockquote>
<p><strong>我：</strong>块数据能够给个人带来更好地体验，给企业带来更高利润，这决定了它必然会成为市场十分受欢迎的商品。<strong>数据商品化</strong>，必然催生出<strong>数据交易市场</strong>，那么自然而然有了<strong>数据金融</strong>，这一循行路径是：数据价值化——价值资产化——资产资本化——资本证券化，在这个“块”内，数据确权、数据定价、数据保险、以及数据的登记、交割等一系列新的产业链产生，所以我觉得数据期货、数据信托、数据银行、数据结算等的出现都只是时间问题。</p>
</blockquote>
<p><strong>小结</strong><br>　　这本书给我最深记忆的部分就是上面一小问（数据变成一门生意），一直以来，我看书形成的癖好就是太多的关注于技术层面的东西，觉得商业离我很远，眼界不够开阔，最近每天来回实验室路上听听<strong>得到</strong>，越发觉得自己的无知，这些商业模式，企业故事啊，真的超有意思，个人觉得，这个时代，你的格局，idea是最重要的，在学校听讲座多了对教授，专家形成了些许偏见，总觉得他们说的假大空，只会纸上谈兵，那些来自一线的技术人员才干货满满，但这本书让我对他们有些改观，方向性指导还是很重要的，只有方向对了，技术实现只是时间早晚的问题。</p>
<center><strong>Every little helps a mickle.</strong></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;本书是大数据战略重点实验室编写，是实验室集中一批大数据领域专家学者、实践者和郑策制定者的力量，在调研大量大数据企业、相关政府职能部门、各类社会组织后集中撰写的。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://phoebepan.cn/categories/Thinking/"/>
    
    
      <category term="Reading" scheme="http://phoebepan.cn/tags/Reading/"/>
    
      <category term="Thinking" scheme="http://phoebepan.cn/tags/Thinking/"/>
    
  </entry>
  
</feed>
